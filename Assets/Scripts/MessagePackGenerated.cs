// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Resolvers
{
    using System;

    public class GeneratedResolver : global::MessagePack.IFormatterResolver
    {
        public static readonly global::MessagePack.IFormatterResolver Instance = new GeneratedResolver();

        private GeneratedResolver()
        {
        }

        public global::MessagePack.Formatters.IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            internal static readonly global::MessagePack.Formatters.IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                var f = GeneratedResolverGetFormatterHelper.GetFormatter(typeof(T));
                if (f != null)
                {
                    Formatter = (global::MessagePack.Formatters.IMessagePackFormatter<T>)f;
                }
            }
        }
    }

    internal static class GeneratedResolverGetFormatterHelper
    {
        private static readonly global::System.Collections.Generic.Dictionary<Type, int> lookup;

        static GeneratedResolverGetFormatterHelper()
        {
            lookup = new global::System.Collections.Generic.Dictionary<Type, int>(18)
            {
                { typeof(global::System.Collections.Generic.Dictionary<int, global::LevelStat>), 0 },
                { typeof(global::System.Collections.Generic.Dictionary<int, int>), 1 },
                { typeof(global::System.Collections.Generic.List<global::Connection>), 2 },
                { typeof(global::System.Collections.Generic.List<global::Item>), 3 },
                { typeof(global::System.Collections.Generic.List<global::Level>), 4 },
                { typeof(global::System.Collections.Generic.List<global::Rope>), 5 },
                { typeof(global::System.Collections.Generic.List<global::Wall>), 6 },
                { typeof(global::System.Collections.Generic.List<global::Zone>), 7 },
                { typeof(global::ItemType), 8 },
                { typeof(global::Connection), 9 },
                { typeof(global::Item), 10 },
                { typeof(global::Level), 11 },
                { typeof(global::Levels), 12 },
                { typeof(global::LevelStat), 13 },
                { typeof(global::LevelStatsObject), 14 },
                { typeof(global::Rope), 15 },
                { typeof(global::Wall), 16 },
                { typeof(global::Zone), 17 },
            };
        }

        internal static object GetFormatter(Type t)
        {
            int key;
            if (!lookup.TryGetValue(t, out key))
            {
                return null;
            }

            switch (key)
            {
                case 0: return new global::MessagePack.Formatters.DictionaryFormatter<int, global::LevelStat>();
                case 1: return new global::MessagePack.Formatters.DictionaryFormatter<int, int>();
                case 2: return new global::MessagePack.Formatters.ListFormatter<global::Connection>();
                case 3: return new global::MessagePack.Formatters.ListFormatter<global::Item>();
                case 4: return new global::MessagePack.Formatters.ListFormatter<global::Level>();
                case 5: return new global::MessagePack.Formatters.ListFormatter<global::Rope>();
                case 6: return new global::MessagePack.Formatters.ListFormatter<global::Wall>();
                case 7: return new global::MessagePack.Formatters.ListFormatter<global::Zone>();
                case 8: return new MessagePack.Formatters.ItemTypeFormatter();
                case 9: return new MessagePack.Formatters.ConnectionFormatter();
                case 10: return new MessagePack.Formatters.ItemFormatter();
                case 11: return new MessagePack.Formatters.LevelFormatter();
                case 12: return new MessagePack.Formatters.LevelsFormatter();
                case 13: return new MessagePack.Formatters.LevelStatFormatter();
                case 14: return new MessagePack.Formatters.LevelStatsObjectFormatter();
                case 15: return new MessagePack.Formatters.RopeFormatter();
                case 16: return new MessagePack.Formatters.WallFormatter();
                case 17: return new MessagePack.Formatters.ZoneFormatter();
                default: return null;
            }
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1649 // File name should match first type name


// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class ItemTypeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::ItemType>
    {
        public void Serialize(ref MessagePackWriter writer, global::ItemType value, global::MessagePack.MessagePackSerializerOptions options)
        {
            writer.Write((Byte)value);
        }

        public global::ItemType Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            return (global::ItemType)reader.ReadByte();
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name



// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters
{
    using System;
    using System.Buffers;
    using System.Runtime.InteropServices;
    using MessagePack;

    public sealed class ConnectionFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Connection>
    {
        // connX
        private static global::System.ReadOnlySpan<byte> GetSpan_connX() => new byte[1 + 5] { 165, 99, 111, 110, 110, 88 };
        // connY
        private static global::System.ReadOnlySpan<byte> GetSpan_connY() => new byte[1 + 5] { 165, 99, 111, 110, 110, 89 };

        public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::Connection value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value is null)
            {
                writer.WriteNil();
                return;
            }

            writer.WriteMapHeader(2);
            writer.WriteRaw(GetSpan_connX());
            writer.Write(value.connX);
            writer.WriteRaw(GetSpan_connY());
            writer.Write(value.connY);
        }

        public global::Connection Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadMapHeader();
            var __connX__ = default(int);
            var __connY__ = default(int);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                switch (stringKey.Length)
                {
                    default:
                    FAIL:
                      reader.Skip();
                      continue;
                    case 5:
                        switch (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey))
                        {
                            default: goto FAIL;
                            case 379809853283UL:
                                __connX__ = reader.ReadInt32();
                                continue;
                            case 384104820579UL:
                                __connY__ = reader.ReadInt32();
                                continue;
                        }

                }
            }

            var ____result = new global::Connection()
            {
                connX = __connX__,
                connY = __connY__,
            };

            reader.Depth--;
            return ____result;
        }
    }

    public sealed class ItemFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Item>
    {
        // Type
        private static global::System.ReadOnlySpan<byte> GetSpan_itemType() => new byte[1 + 4] { 164, 84, 121, 112, 101 };
        // X
        private static global::System.ReadOnlySpan<byte> GetSpan_itemX() => new byte[1 + 1] { 161, 88 };
        // Y
        private static global::System.ReadOnlySpan<byte> GetSpan_itemY() => new byte[1 + 1] { 161, 89 };

        public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::Item value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value is null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(3);
            writer.WriteRaw(GetSpan_itemType());
            formatterResolver.GetFormatterWithVerify<global::ItemType>().Serialize(ref writer, value.itemType, options);
            writer.WriteRaw(GetSpan_itemX());
            writer.Write(value.itemX);
            writer.WriteRaw(GetSpan_itemY());
            writer.Write(value.itemY);
        }

        public global::Item Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __itemType__ = default(global::ItemType);
            var __itemX__ = default(int);
            var __itemY__ = default(int);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                switch (stringKey.Length)
                {
                    default:
                    FAIL:
                      reader.Skip();
                      continue;
                    case 4:
                        if (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey) != 1701869908UL) { goto FAIL; }

                        __itemType__ = formatterResolver.GetFormatterWithVerify<global::ItemType>().Deserialize(ref reader, options);
                        continue;
                    case 1:
                        switch (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey))
                        {
                            default: goto FAIL;
                            case 88UL:
                                __itemX__ = reader.ReadInt32();
                                continue;
                            case 89UL:
                                __itemY__ = reader.ReadInt32();
                                continue;
                        }

                }
            }

            var ____result = new global::Item()
            {
                itemType = __itemType__,
                itemX = __itemX__,
                itemY = __itemY__,
            };

            reader.Depth--;
            return ____result;
        }
    }

    public sealed class LevelFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Level>
    {
        // levelID
        private static global::System.ReadOnlySpan<byte> GetSpan_levelID() => new byte[1 + 7] { 167, 108, 101, 118, 101, 108, 73, 68 };
        // sizeX
        private static global::System.ReadOnlySpan<byte> GetSpan_levelSizeX() => new byte[1 + 5] { 165, 115, 105, 122, 101, 88 };
        // sizeY
        private static global::System.ReadOnlySpan<byte> GetSpan_levelSizeY() => new byte[1 + 5] { 165, 115, 105, 122, 101, 89 };
        // items
        private static global::System.ReadOnlySpan<byte> GetSpan_itemsList() => new byte[1 + 5] { 165, 105, 116, 101, 109, 115 };
        // wallsL
        private static global::System.ReadOnlySpan<byte> GetSpan_wallsLList() => new byte[1 + 6] { 166, 119, 97, 108, 108, 115, 76 };
        // wallsB
        private static global::System.ReadOnlySpan<byte> GetSpan_wallsBList() => new byte[1 + 6] { 166, 119, 97, 108, 108, 115, 66 };
        // zones
        private static global::System.ReadOnlySpan<byte> GetSpan_zonesList() => new byte[1 + 5] { 165, 122, 111, 110, 101, 115 };
        // ropes
        private static global::System.ReadOnlySpan<byte> GetSpan_ropesList() => new byte[1 + 5] { 165, 114, 111, 112, 101, 115 };
        // redMoves
        private static global::System.ReadOnlySpan<byte> GetSpan_redMoves() => new byte[1 + 8] { 168, 114, 101, 100, 77, 111, 118, 101, 115 };
        // blueMoves
        private static global::System.ReadOnlySpan<byte> GetSpan_blueMoves() => new byte[1 + 9] { 169, 98, 108, 117, 101, 77, 111, 118, 101, 115 };
        // yellowMoves
        private static global::System.ReadOnlySpan<byte> GetSpan_yellowMoves() => new byte[1 + 11] { 171, 121, 101, 108, 108, 111, 119, 77, 111, 118, 101, 115 };
        // greenMoves
        private static global::System.ReadOnlySpan<byte> GetSpan_greenMoves() => new byte[1 + 10] { 170, 103, 114, 101, 101, 110, 77, 111, 118, 101, 115 };
        // timeLimit
        private static global::System.ReadOnlySpan<byte> GetSpan_timeLimit() => new byte[1 + 9] { 169, 116, 105, 109, 101, 76, 105, 109, 105, 116 };
        // maxPoint
        private static global::System.ReadOnlySpan<byte> GetSpan_maxPoint() => new byte[1 + 8] { 168, 109, 97, 120, 80, 111, 105, 110, 116 };

        public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::Level value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value is null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(14);
            writer.WriteRaw(GetSpan_levelID());
            writer.Write(value.levelID);
            writer.WriteRaw(GetSpan_levelSizeX());
            writer.Write(value.levelSizeX);
            writer.WriteRaw(GetSpan_levelSizeY());
            writer.Write(value.levelSizeY);
            writer.WriteRaw(GetSpan_itemsList());
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.List<global::Item>>().Serialize(ref writer, value.itemsList, options);
            writer.WriteRaw(GetSpan_wallsLList());
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.List<global::Wall>>().Serialize(ref writer, value.wallsLList, options);
            writer.WriteRaw(GetSpan_wallsBList());
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.List<global::Wall>>().Serialize(ref writer, value.wallsBList, options);
            writer.WriteRaw(GetSpan_zonesList());
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.List<global::Zone>>().Serialize(ref writer, value.zonesList, options);
            writer.WriteRaw(GetSpan_ropesList());
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.List<global::Rope>>().Serialize(ref writer, value.ropesList, options);
            writer.WriteRaw(GetSpan_redMoves());
            writer.Write(value.redMoves);
            writer.WriteRaw(GetSpan_blueMoves());
            writer.Write(value.blueMoves);
            writer.WriteRaw(GetSpan_yellowMoves());
            writer.Write(value.yellowMoves);
            writer.WriteRaw(GetSpan_greenMoves());
            writer.Write(value.greenMoves);
            writer.WriteRaw(GetSpan_timeLimit());
            writer.Write(value.timeLimit);
            writer.WriteRaw(GetSpan_maxPoint());
            writer.Write(value.maxPoint);
        }

        public global::Level Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __levelID__ = default(int);
            var __levelSizeX__ = default(int);
            var __levelSizeY__ = default(int);
            var __itemsList__ = default(global::System.Collections.Generic.List<global::Item>);
            var __wallsLList__ = default(global::System.Collections.Generic.List<global::Wall>);
            var __wallsBList__ = default(global::System.Collections.Generic.List<global::Wall>);
            var __zonesList__ = default(global::System.Collections.Generic.List<global::Zone>);
            var __ropesList__ = default(global::System.Collections.Generic.List<global::Rope>);
            var __redMoves__ = default(int);
            var __blueMoves__ = default(int);
            var __yellowMoves__ = default(int);
            var __greenMoves__ = default(int);
            var __timeLimit__ = default(int);
            var __maxPoint__ = default(int);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                switch (stringKey.Length)
                {
                    default:
                    FAIL:
                      reader.Skip();
                      continue;
                    case 7:
                        if (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey) != 19221028323878252UL) { goto FAIL; }

                        __levelID__ = reader.ReadInt32();
                        continue;
                    case 5:
                        switch (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey))
                        {
                            default: goto FAIL;
                            case 379659643251UL:
                                __levelSizeX__ = reader.ReadInt32();
                                continue;
                            case 383954610547UL:
                                __levelSizeY__ = reader.ReadInt32();
                                continue;
                            case 495756604521UL:
                                __itemsList__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.List<global::Item>>().Deserialize(ref reader, options);
                                continue;
                            case 495622975354UL:
                                __zonesList__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.List<global::Zone>>().Deserialize(ref reader, options);
                                continue;
                            case 495623106418UL:
                                __ropesList__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.List<global::Rope>>().Deserialize(ref reader, options);
                                continue;
                        }
                    case 6:
                        switch (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey))
                        {
                            default: goto FAIL;
                            case 84058623992183UL:
                                __wallsLList__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.List<global::Wall>>().Deserialize(ref reader, options);
                                continue;
                            case 73063507714423UL:
                                __wallsBList__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.List<global::Wall>>().Deserialize(ref reader, options);
                                continue;
                        }
                    case 8:
                        switch (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey))
                        {
                            default: goto FAIL;
                            case 8315182507421361522UL:
                                __redMoves__ = reader.ReadInt32();
                                continue;
                            case 8389759082650165613UL:
                                __maxPoint__ = reader.ReadInt32();
                                continue;
                        }
                    case 9:
                        switch (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey))
                        {
                            default: goto FAIL;
                            case 7311153423287938146UL:
                                if (stringKey[0] != 115) { goto FAIL; }

                                __blueMoves__ = reader.ReadInt32();
                                continue;

                            case 7596843923283994996UL:
                                if (stringKey[0] != 116) { goto FAIL; }

                                __timeLimit__ = reader.ReadInt32();
                                continue;

                        }
                    case 11:
                        if (!global::System.MemoryExtensions.SequenceEqual(stringKey, GetSpan_yellowMoves().Slice(1))) { goto FAIL; }

                        __yellowMoves__ = reader.ReadInt32();
                        continue;
                    case 10:
                        if (!global::System.MemoryExtensions.SequenceEqual(stringKey, GetSpan_greenMoves().Slice(1))) { goto FAIL; }

                        __greenMoves__ = reader.ReadInt32();
                        continue;

                }
            }

            var ____result = new global::Level()
            {
                levelID = __levelID__,
                levelSizeX = __levelSizeX__,
                levelSizeY = __levelSizeY__,
                itemsList = __itemsList__,
                wallsLList = __wallsLList__,
                wallsBList = __wallsBList__,
                zonesList = __zonesList__,
                ropesList = __ropesList__,
                redMoves = __redMoves__,
                blueMoves = __blueMoves__,
                yellowMoves = __yellowMoves__,
                greenMoves = __greenMoves__,
                timeLimit = __timeLimit__,
                maxPoint = __maxPoint__,
            };

            reader.Depth--;
            return ____result;
        }
    }

    public sealed class RopeFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Rope>
    {
        // ropeConnectionList
        private static global::System.ReadOnlySpan<byte> GetSpan_ropeConnections() => new byte[1 + 18] { 178, 114, 111, 112, 101, 67, 111, 110, 110, 101, 99, 116, 105, 111, 110, 76, 105, 115, 116 };

        public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::Rope value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value is null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(1);
            writer.WriteRaw(GetSpan_ropeConnections());
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.List<global::Connection>>().Serialize(ref writer, value.ropeConnections, options);
        }

        public global::Rope Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __ropeConnections__ = default(global::System.Collections.Generic.List<global::Connection>);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                switch (stringKey.Length)
                {
                    default:
                    FAIL:
                      reader.Skip();
                      continue;
                    case 18:
                        if (!global::System.MemoryExtensions.SequenceEqual(stringKey, GetSpan_ropeConnections().Slice(1))) { goto FAIL; }

                        __ropeConnections__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.List<global::Connection>>().Deserialize(ref reader, options);
                        continue;

                }
            }

            var ____result = new global::Rope()
            {
                ropeConnections = __ropeConnections__,
            };

            reader.Depth--;
            return ____result;
        }
    }

    public sealed class WallFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Wall>
    {
        // wallX
        private static global::System.ReadOnlySpan<byte> GetSpan_wallX() => new byte[1 + 5] { 165, 119, 97, 108, 108, 88 };
        // wallY
        private static global::System.ReadOnlySpan<byte> GetSpan_wallY() => new byte[1 + 5] { 165, 119, 97, 108, 108, 89 };

        public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::Wall value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value is null)
            {
                writer.WriteNil();
                return;
            }

            writer.WriteMapHeader(2);
            writer.WriteRaw(GetSpan_wallX());
            writer.Write(value.wallX);
            writer.WriteRaw(GetSpan_wallY());
            writer.Write(value.wallY);
        }

        public global::Wall Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadMapHeader();
            var __wallX__ = default(int);
            var __wallY__ = default(int);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                switch (stringKey.Length)
                {
                    default:
                    FAIL:
                      reader.Skip();
                      continue;
                    case 5:
                        switch (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey))
                        {
                            default: goto FAIL;
                            case 379776164215UL:
                                __wallX__ = reader.ReadInt32();
                                continue;
                            case 384071131511UL:
                                __wallY__ = reader.ReadInt32();
                                continue;
                        }

                }
            }

            var ____result = new global::Wall()
            {
                wallX = __wallX__,
                wallY = __wallY__,
            };

            reader.Depth--;
            return ____result;
        }
    }

    public sealed class ZoneFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Zone>
    {
        // zoneConnectionList
        private static global::System.ReadOnlySpan<byte> GetSpan_zoneConnections() => new byte[1 + 18] { 178, 122, 111, 110, 101, 67, 111, 110, 110, 101, 99, 116, 105, 111, 110, 76, 105, 115, 116 };

        public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::Zone value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value is null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteMapHeader(1);
            writer.WriteRaw(GetSpan_zoneConnections());
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.List<global::Connection>>().Serialize(ref writer, value.zoneConnections, options);
        }

        public global::Zone Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var __zoneConnections__ = default(global::System.Collections.Generic.List<global::Connection>);

            for (int i = 0; i < length; i++)
            {
                ReadOnlySpan<byte> stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                switch (stringKey.Length)
                {
                    default:
                    FAIL:
                      reader.Skip();
                      continue;
                    case 18:
                        if (!global::System.MemoryExtensions.SequenceEqual(stringKey, GetSpan_zoneConnections().Slice(1))) { goto FAIL; }

                        __zoneConnections__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.List<global::Connection>>().Deserialize(ref reader, options);
                        continue;

                }
            }

            var ____result = new global::Zone()
            {
                zoneConnections = __zoneConnections__,
            };

            reader.Depth--;
            return ____result;
        }
    }
}

// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters
{
    using System;
    using System.Buffers;
    using MessagePack;

    public sealed class LevelsFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Levels>
    {

        public void Serialize(ref MessagePackWriter writer, global::Levels value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(2);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.List<global::Level>>().Serialize(ref writer, value.levelsList, options);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.Dictionary<int, int>>().Serialize(ref writer, value.statePoints, options);
        }

        public global::Levels Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __levelsList__ = default(global::System.Collections.Generic.List<global::Level>);
            var __statePoints__ = default(global::System.Collections.Generic.Dictionary<int, int>);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __levelsList__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.List<global::Level>>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __statePoints__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.Dictionary<int, int>>().Deserialize(ref reader, options);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::Levels();
            ____result.levelsList = __levelsList__;
            ____result.statePoints = __statePoints__;
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class LevelStatFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::LevelStat>
    {

        public void Serialize(ref MessagePackWriter writer, global::LevelStat value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            writer.WriteArrayHeader(6);
            writer.Write(value.levelID);
            writer.Write(value.isLocked);
            writer.Write(value.isPlayable);
            writer.Write(value.isPlayed);
            writer.Write(value.levelStar);
            writer.Write(value.maxPoint);
        }

        public global::LevelStat Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var length = reader.ReadArrayHeader();
            var __levelID__ = default(int);
            var __isLocked__ = default(bool);
            var __isPlayable__ = default(bool);
            var __isPlayed__ = default(bool);
            var __levelStar__ = default(byte);
            var __maxPoint__ = default(int);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __levelID__ = reader.ReadInt32();
                        break;
                    case 1:
                        __isLocked__ = reader.ReadBoolean();
                        break;
                    case 2:
                        __isPlayable__ = reader.ReadBoolean();
                        break;
                    case 3:
                        __isPlayed__ = reader.ReadBoolean();
                        break;
                    case 4:
                        __levelStar__ = reader.ReadByte();
                        break;
                    case 5:
                        __maxPoint__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::LevelStat();
            ____result.levelID = __levelID__;
            ____result.isLocked = __isLocked__;
            ____result.isPlayable = __isPlayable__;
            ____result.isPlayed = __isPlayed__;
            ____result.levelStar = __levelStar__;
            ____result.maxPoint = __maxPoint__;
            reader.Depth--;
            return ____result;
        }
    }

    public sealed class LevelStatsObjectFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::LevelStatsObject>
    {

        public void Serialize(ref MessagePackWriter writer, global::LevelStatsObject value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

            IFormatterResolver formatterResolver = options.Resolver;
            writer.WriteArrayHeader(4);
            formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.Dictionary<int, global::LevelStat>>().Serialize(ref writer, value.levelStatsDict, options);
            writer.Write(value.lastPlayedLevel);
            writer.Write(value.lastOpenedLevel);
            writer.Write(value.lastOpenedState);
        }

        public global::LevelStatsObject Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            IFormatterResolver formatterResolver = options.Resolver;
            var length = reader.ReadArrayHeader();
            var __levelStatsDict__ = default(global::System.Collections.Generic.Dictionary<int, global::LevelStat>);
            var __lastPlayedLevel__ = default(int);
            var __lastOpenedLevel__ = default(int);
            var __lastOpenedState__ = default(int);

            for (int i = 0; i < length; i++)
            {
                switch (i)
                {
                    case 0:
                        __levelStatsDict__ = formatterResolver.GetFormatterWithVerify<global::System.Collections.Generic.Dictionary<int, global::LevelStat>>().Deserialize(ref reader, options);
                        break;
                    case 1:
                        __lastPlayedLevel__ = reader.ReadInt32();
                        break;
                    case 2:
                        __lastOpenedLevel__ = reader.ReadInt32();
                        break;
                    case 3:
                        __lastOpenedState__ = reader.ReadInt32();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            var ____result = new global::LevelStatsObject();
            ____result.levelStatsDict = __levelStatsDict__;
            ____result.lastPlayedLevel = __lastPlayedLevel__;
            ____result.lastOpenedLevel = __lastOpenedLevel__;
            ____result.lastOpenedState = __lastOpenedState__;
            reader.Depth--;
            return ____result;
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

